{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "prompt-handler",
  "type": "registry:file",
  "title": "Prompt Handler",
  "description": "A prompt handler package",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/recipes/packages/py-prompthandler/package.json",
      "content": "{\n    \"name\": \"py-prompthandler\",\n    \"version\": \"2025.1\",\n    \"private\": true,\n    \"description\": \"ML backend: Prompt handler\",\n    \"scripts\": {\n        \"build\": \"echo 'Python ML backend: Prompt handler - no build step needed'\",\n        \"test\": \"uv run pytest\",\n        \"test:watch\": \"echo 'Pytest watch mode is not configured' >&2 && exit 1\",\n        \"lint\": \"uv run ruff check\",\n        \"lint:fix\": \"uv run ruff check --fix\",\n        \"format\": \"uv run ruff check --select I,RUF022 --fix && uv run ruff format\",\n        \"format:check\": \"uv run ruff format --check\",\n        \"type-check\": \"uv run mypy --namespace-packages --explicit-package-bases src/\",\n        \"clean\": \"find . -type d -name '__pycache__' -exec rm -rf {} + 2>/dev/null || true; find . -name '*.pyc' -delete 2>/dev/null || true\",\n        \"install\": \"uv sync\"\n    },\n    \"dependencies\": {},\n    \"devDependencies\": {}\n}",
      "type": "registry:file",
      "target": "packages/py-prompthandler/package.json"
    },
    {
      "path": "registry/recipes/packages/py-prompthandler/pyproject.toml",
      "content": "[project]\nname = \"py-prompthandler\"\nversion = \"2025.1\"\ndescription = \"ML backend: prompt handler\"\nreadme = \"README.md\"\n\ndependencies = [\n    \"pydantic>=2.11\",\n    \"jinja2>=3.1.6\",\n]\n\n[dependency-groups]\ndev = [\n    \"pytest>=7.4.0\",\n    \"ruff>=0.1.0\",\n    \"mypy>=1.6.0\",\n]\n\n[build-system]\nrequires = [\"setuptools >= 64.0.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]",
      "type": "registry:file",
      "target": "packages/py-prompthandler/pyproject.toml"
    },
    {
      "path": "registry/recipes/packages/py-prompthandler/PROMPT-HANDLER.MD",
      "content": "## py-prompthandler\n\n`py-prompthandler` is a small Python library used as the **ML backend prompt handler** in this repository.  \nIt provides an abstract `BasePromptHandler` plus a concrete `InMemoryPromptHandler` implementation to:\n\n- **Create** prompts and store them (e.g. in memory or in another backend you implement).\n- **Retrieve** prompts by name, including **nested prompts** that can reference each other.\n- **Render / compile** prompts with:\n  - Python-style `{variable}` placeholders.\n  - Jinja2-style `[[ variable ]]` expressions with auto-escaping.\n\nThis package is intended to be embedded inside ML services or workers that need a simple but flexible prompt-management layer.\n\n---\n\n## What the package does\n\n- **`BasePromptHandler` (`base.py`)**\n  - Defines the core interface for any prompt handler:\n    - `create_prompt(name, content, **kwargs)`: create or register a prompt.\n    - `_get_prompt(name, context=None, **kwargs) -> str`: low-level retrieval method, to be implemented by subclasses.\n    - `get_prompt(name, context=None, max_recursion=5, auto_compile=False, ...) -> str`:\n      - Fetches a prompt by name.\n      - Supports **nested prompts**: missing `{variable}` placeholders can be resolved by calling `get_prompt` recursively on other prompt names.\n      - Optionally compiles placeholders using the provided `context`.\n    - `compile_prompt(content, context) -> str`: convenience `{key}`-style string formatting.\n    - `update_prompt(name, content, **kwargs)`: update an existing prompt.\n\n- **`InMemoryPromptHandler` (`in_memory.py`)**\n  - Stores prompts in a simple in-memory `dict[str, str]`.\n  - Normalizes mixed Jinja / format syntax:\n    - Converts `{{ var }}` to `{var}` so it can be handled by the base class.\n  - Uses **Jinja2** with `[[ ... ]]` delimiters for templating, with auto-escaping enabled.\n  - Offers a `from_module(prompt_module)` helper:\n    - Scans a Python module for **UPPER_CASE string constants** and turns them into prompts.\n\n- **Tests (`test_in_memory.py`)**\n  - Cover initialization, creation, update, nested / auto-compiled prompts and various Jinja2 rendering behaviours.\n\n---\n\n## Python dependencies\n\nThe canonical dependency list is defined in `pyprompt.toml`:\n\n- **Runtime dependencies**\n  - `pydantic>=2.11`\n  - `jinja2>=3.1.6`\n\n- **Dev / tooling dependencies**\n  - `pytest>=7.4.0` (test runner)\n  - `ruff>=0.1.0` (linting & formatting)\n  - `mypy>=1.6.0` (type checking)\n\nThe project uses **setuptools** for packaging and expects `src`-based layout per `pyprompt.toml`.\n\n---\n\n## Recommended installation (local dev / ML environment)\n\nYou can install dependencies either with `uv` (preferred in this repo) or with `pip`.\n\n### Option 1 – Using `uv` (recommended)\n\nFrom `registry/recipes/packages/prompt-handler/`:\n\n```bash\nuv sync\n```\n\nThis will install both runtime and dev dependencies as defined in `pyprompt.toml`.\n\n### Option 2 – Using `pip`\n\nIf you prefer a plain `pip` workflow, install the equivalent dependencies manually:\n\n```bash\npip install \"pydantic>=2.11\" \"jinja2>=3.1.6\"\n\n# For development / running tests:\npip install \"pytest>=7.4.0\" \"ruff>=0.1.0\" \"mypy>=1.6.0\"\n```\n\n---\n\n## Basic usage examples\n\n### In-memory handler\n\n```python\nfrom faktion.prompthandler.in_memory import InMemoryPromptHandler\n\nhandler = InMemoryPromptHandler()\nhandler.create_prompt(\"GREETING\", \"Hello {name}!\")\n\n# Just retrieve the template\ntemplate = handler.get_prompt(\"GREETING\")\n# \"Hello {name}!\"\n\n# Retrieve and compile with context\nprompt = handler.get_prompt(\"GREETING\", context={\"name\": \"Alice\"}, auto_compile=True)\n# \"Hello Alice!\"\n```\n\n### Using nested prompts\n\n```python\nhandler = InMemoryPromptHandler(\n    prompts={\n        \"BASE\": \"User: {USER_NAME}\",\n        \"USER_NAME\": \"{first_name} {last_name}\",\n    }\n)\n\nprompt = handler.get_prompt(\n    \"BASE\",\n    context={\"first_name\": \"Ada\", \"last_name\": \"Lovelace\"},\n    auto_compile=True,\n)\n# \"User: Ada Lovelace\"\n```\n\n### Using Jinja2-style `[[ ... ]]` variables\n\n```python\nhandler = InMemoryPromptHandler()\nhandler.create_prompt(\"STATS\", \"Hello [[ user_name ]]! Count: [[ count ]]\")\n\nprompt = handler.get_prompt(\"STATS\", user_name=\"Alice\", count=5, auto_compile=True)\n# \"Hello Alice! Count: 5\"\n```\n\n---\n\n## How to use this in an ML service\n\n- **Centralise prompt definitions** in a Python module or config, then:\n  - Load them into an `InMemoryPromptHandler` (or your own subclass backed by DB / files / API).\n  - Use `get_prompt(...)` to assemble the final prompt just before calling your LLM.\n- **Leverage nested prompts** for reusable sub-components (headers, footers, system messages).\n- **Use Jinja2 templating** for more complex logic while keeping the base API simple.\n\nThis gives your ML service a clear, testable layer for prompt management, decoupled from the rest of the application logic.",
      "type": "registry:file",
      "target": "docs/PROMPT-HANDLER.MD"
    },
    {
      "path": "registry/recipes/packages/py-prompthandler/__init__.py",
      "content": "from .base import BasePromptHandler\n\n__all__ = [\"BasePromptHandler\"]",
      "type": "registry:file",
      "target": "packages/py-prompthandler/src/faktion/prompthandler/__init__.py"
    },
    {
      "path": "registry/recipes/packages/py-prompthandler/base.py",
      "content": "import re\nfrom abc import ABC, abstractmethod\nfrom typing import Any\n\n\nclass BasePromptHandler(ABC):\n    \"\"\"Base class for all prompt handlers.\"\"\"\n\n    @abstractmethod\n    def create_prompt(self, name: str, content: str, *args, **kwargs):\n        \"\"\"\n        Create a new prompt with the given name and content.\n\n        Args:\n            name (str): Name of the prompt.\n            content (str): Content of the prompt.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _get_prompt(self, name: str, context: dict[str, Any] | None = None, *args, **kwargs) -> str:\n        \"\"\"\n        Get the content of a prompt with the given name.\n\n        Args:\n            name (str): Name of the prompt.\n            context (dict[str, str] | None, optional): A dictionary of parameters to be used for replacing variables in the prompt content. Defaults to None.\n\n        Returns:\n            str: The content of the prompt.\n        \"\"\"\n        pass\n\n    def get_prompt(\n        self,\n        name: str,\n        context: (\n            dict[str, Any] | None\n        ) = None,  # This can be used to retrieve nested prompts. If context is None, the prompt is returned as is without looking for nested prompts.\n        max_recursion: int = 5,\n        auto_compile: bool = False,\n        raise_on_missing_input: bool = True,\n        _is_recursive: bool = False,\n        *args,\n        **kwargs,\n    ) -> str:\n        \"\"\"\n        Get the prompt content for a given name. Each prompt handler fetches the prompt content from the corresponding source. This function can be used to retrieve nested prompts by providing a context dictionary.\n\n        Args:\n            name (str): The name of the prompt.\n            context (dict[str, str]  |  None, optional): A dictionary of parameters to be used for replacing variables in the prompt content. Defaults to None.\n            auto_compile (bool, optional): Whether to automatically compile the prompt content by replacing variables with their corresponding values. Defaults to False.\n            raise_on_missing_input (bool, optional): Whether to raise an error if any input parameters are missing. Defaults to True.\n            _is_recursive (bool, optional): Internal flag to indicate if the function is being called recursively. Defaults to False.\n\n        Raises:\n            ValueError: If the prompt with the given name is not found.\n            ValueError: If any input parameters are missing and the maximum recursion depth is reached.\n            ValueError: If any other error occurs while retrieving the prompt.\n\n        Returns:\n            str: The prompt content.\n        \"\"\"\n        name = name.strip()\n        try:\n            content = self._get_prompt(name=name, *args, **kwargs)  # type: ignore[misc]\n        except Exception:\n            if not _is_recursive:\n                raise ValueError(f'Prompt or variable with name \"{name}\" not found.')\n            else:\n                if raise_on_missing_input:\n                    raise ValueError(f'Prompt or variable with name \"{name}\" not found.')\n                else:\n                    return f\"{{{name}}}\"\n\n        if context is None:\n            return content\n        prompt_variables = set(re.findall(r\"\\{(.*?)\\}\", content))\n        missing_context_keys = list(prompt_variables - set(context.keys()))\n        if len(missing_context_keys) > 0:\n            if max_recursion == 0:\n                if raise_on_missing_input:\n                    raise ValueError(f\"Missing input context: {missing_context_keys} - max recursion reached.\")\n                else:\n                    return content\n            for missing_variable in missing_context_keys:\n                try:\n                    inner_content = self.get_prompt(  # type: ignore[misc]\n                        name=missing_variable,\n                        context=context,\n                        raise_on_missing_input=raise_on_missing_input,\n                        max_recursion=max_recursion - 1,\n                        _is_recursive=True,\n                        *args,\n                        **kwargs,\n                    )\n                except ValueError as e:\n                    raise e\n                content = content.replace(f\"{{{missing_variable}}}\", inner_content)\n        if not _is_recursive and auto_compile:\n            for key, value in context.items():\n                content = content.replace(f\"{{{key}}}\", str(value))\n        return content\n\n    def compile_prompt(self, content: str, context: dict[str, Any]) -> str:\n        \"\"\"\n        Compile the prompt by replacing placeholders with provided parameters.\n\n        Args:\n            content (str): The content of the prompt with placeholders.\n            context (dict[str, str]): A dictionary containing the parameter values to replace the placeholders.\n\n        Returns:\n            str: The compiled prompt with placeholders replaced by parameter values.\n        \"\"\"\n        return content.format(**context)\n\n    @abstractmethod\n    def update_prompt(self, name: str, content: str, *args, **kwargs):\n        \"\"\"\n        Update the content of an existing prompt with the given name.\n\n        Args:\n            name (str): Name of the prompt.\n            content (str): New content of the prompt.\n        \"\"\"\n        pass",
      "type": "registry:file",
      "target": "packages/py-prompthandler/src/faktion/prompthandler/base.py"
    },
    {
      "path": "registry/recipes/packages/py-prompthandler/in_memory.py",
      "content": "import re\nfrom types import ModuleType\n\nfrom jinja2 import BaseLoader, Environment\n\nfrom .base import BasePromptHandler\n\n\nclass InMemoryPromptHandler(BasePromptHandler):\n    \"\"\"\n    InMemoryPromptHandler handles prompts in memory.\n    \"\"\"\n\n    def __init__(self, prompts: dict[str, str] | None = None) -> None:\n        \"\"\"\n        Initialize a Prompt handler that saves prompts in memory.\n\n        Args:\n            prompts (dict[str, str] | None, optional): A dictionary of prompts, If None an empty dictionary is used meaning there are no existing prompts yet. Defaults to None.\n        \"\"\"\n        super().__init__()\n        self.prompts = prompts or dict()\n\n    def create_prompt(self, name: str, content: str, *args, **kwargs):\n        \"\"\"\n        Create a new prompt with the given name and content.\n\n        Args:\n            name (str): Name of the prompt.\n            content (str): Content of the prompt.\n        \"\"\"\n        self.prompts[name] = content\n\n    def _get_prompt(\n        self,\n        name: str,\n        *args,\n        **kwargs,\n    ) -> str:\n        \"\"\"\n        Get the content of a prompt with the given name.\n\n        Args:\n            name (str): Name of the prompt.\n\n        Returns:\n            str: The content of the prompt.\n        \"\"\"\n        content = self.prompts[name]\n        content = re.sub(r\"{{\\s*(\\w+)\\s*}}\", r\"{\\g<1>}\", content)\n        env = Environment(\n            loader=BaseLoader(),\n            autoescape=True,\n            variable_start_string=\"[[\",\n            variable_end_string=\"]]\",\n        ).from_string(content)\n        prompt = env.render(**kwargs)\n        return prompt\n\n    def update_prompt(self, name: str, content: str, *args, **kwargs):\n        \"\"\"\n        Update the content of a prompt with the given name.\n\n        Args:\n            name (str): The name of the prompt.\n            content (str): The content of the prompt.\n        \"\"\"\n        return self.create_prompt(name=name, content=content, *args, **kwargs)  # type: ignore[misc]\n\n    @staticmethod\n    def from_module(prompt_module: ModuleType) -> \"InMemoryPromptHandler\":\n        \"\"\"Create a handler from a Python module with prompts as constants.\n\n        Converts string variables with upper-case names into prompts.\n        \"\"\"\n        module_attrs = vars(prompt_module)\n\n        prompts = {}\n        for name, value in module_attrs.items():\n            if name.startswith(\"_\"):\n                continue\n            if not name.isupper():\n                continue\n            if not isinstance(value, str):\n                continue\n\n            prompts[name] = value\n\n        if not prompts:\n            raise ValueError(\"No prompts found in module\", prompt_module.__package__, list(module_attrs.keys()))\n\n        handler = InMemoryPromptHandler(prompts=prompts)\n        return handler",
      "type": "registry:file",
      "target": "packages/py-prompthandler/src/faktion/prompthandler/in_memory.py"
    },
    {
      "path": "registry/recipes/packages/py-prompthandler/conftest.py",
      "content": "import re\nfrom types import ModuleType\n\nfrom jinja2 import BaseLoader, Environment\n\nfrom .base import BasePromptHandler\n\n\nclass InMemoryPromptHandler(BasePromptHandler):\n    \"\"\"\n    InMemoryPromptHandler handles prompts in memory.\n    \"\"\"\n\n    def __init__(self, prompts: dict[str, str] | None = None) -> None:\n        \"\"\"\n        Initialize a Prompt handler that saves prompts in memory.\n\n        Args:\n            prompts (dict[str, str] | None, optional): A dictionary of prompts, If None an empty dictionary is used meaning there are no existing prompts yet. Defaults to None.\n        \"\"\"\n        super().__init__()\n        self.prompts = prompts or dict()\n\n    def create_prompt(self, name: str, content: str, *args, **kwargs):\n        \"\"\"\n        Create a new prompt with the given name and content.\n\n        Args:\n            name (str): Name of the prompt.\n            content (str): Content of the prompt.\n        \"\"\"\n        self.prompts[name] = content\n\n    def _get_prompt(\n        self,\n        name: str,\n        *args,\n        **kwargs,\n    ) -> str:\n        \"\"\"\n        Get the content of a prompt with the given name.\n\n        Args:\n            name (str): Name of the prompt.\n\n        Returns:\n            str: The content of the prompt.\n        \"\"\"\n        content = self.prompts[name]\n        content = re.sub(r\"{{\\s*(\\w+)\\s*}}\", r\"{\\g<1>}\", content)\n        env = Environment(\n            loader=BaseLoader(),\n            autoescape=True,\n            variable_start_string=\"[[\",\n            variable_end_string=\"]]\",\n        ).from_string(content)\n        prompt = env.render(**kwargs)\n        return prompt\n\n    def update_prompt(self, name: str, content: str, *args, **kwargs):\n        \"\"\"\n        Update the content of a prompt with the given name.\n\n        Args:\n            name (str): The name of the prompt.\n            content (str): The content of the prompt.\n        \"\"\"\n        return self.create_prompt(name=name, content=content, *args, **kwargs)  # type: ignore[misc]\n\n    @staticmethod\n    def from_module(prompt_module: ModuleType) -> \"InMemoryPromptHandler\":\n        \"\"\"Create a handler from a Python module with prompts as constants.\n\n        Converts string variables with upper-case names into prompts.\n        \"\"\"\n        module_attrs = vars(prompt_module)\n\n        prompts = {}\n        for name, value in module_attrs.items():\n            if name.startswith(\"_\"):\n                continue\n            if not name.isupper():\n                continue\n            if not isinstance(value, str):\n                continue\n\n            prompts[name] = value\n\n        if not prompts:\n            raise ValueError(\"No prompts found in module\", prompt_module.__package__, list(module_attrs.keys()))\n\n        handler = InMemoryPromptHandler(prompts=prompts)\n        return handler",
      "type": "registry:file",
      "target": "packages/py-prompthandler/src/faktion/prompthandler/test/conftest.py"
    },
    {
      "path": "registry/recipes/packages/py-prompthandler/test_in_memory.py",
      "content": "\"\"\"Tests for InMemoryPromptHandler class.\"\"\"\n\nimport pytest\n\nfrom faktion.prompthandler.in_memory import InMemoryPromptHandler\n\n\nclass TestInMemoryPromptHandler:\n    \"\"\"Test cases for InMemoryPromptHandler class.\"\"\"\n\n    def test_initialization_empty(self):\n        \"\"\"Test initialization with no prompts.\"\"\"\n        handler = InMemoryPromptHandler()\n        assert handler.prompts == {}\n\n    def test_initialization_with_prompts(self, sample_prompts):\n        \"\"\"Test initialization with existing prompts.\"\"\"\n        handler = InMemoryPromptHandler(prompts=sample_prompts)\n        assert handler.prompts == sample_prompts\n\n    def test_create_prompt(self, empty_handler):\n        \"\"\"Test creating a new prompt.\"\"\"\n        empty_handler.create_prompt(\"test\", \"Hello {name}!\")\n        assert empty_handler.prompts[\"test\"] == \"Hello {name}!\"\n\n    def test_create_prompt_overwrite(self, empty_handler):\n        \"\"\"Test creating a prompt that overwrites existing one.\"\"\"\n        empty_handler.create_prompt(\"test\", \"Original\")\n        empty_handler.create_prompt(\"test\", \"Updated\")\n        assert empty_handler.prompts[\"test\"] == \"Updated\"\n\n    def test_get_prompt_basic(self, populated_handler):\n        \"\"\"Test getting a prompt without context.\"\"\"\n        result = populated_handler.get_prompt(\"GREETING\")\n        assert result == \"Hello {name}!\"\n\n    def test_get_prompt_with_context_no_autocompile(self, populated_handler):\n        \"\"\"Test getting a prompt with context.\"\"\"\n        result = populated_handler.get_prompt(\"GREETING\", context={\"name\": \"Alice\"})\n        assert result == \"Hello {name}!\"\n\n    def test_get_prompt_with_context_autocompile(self, populated_handler):\n        \"\"\"Test getting a prompt with context.\"\"\"\n        result = populated_handler.get_prompt(\"GREETING\", context={\"name\": \"Alice\"}, auto_compile=True)\n        assert result == \"Hello Alice!\"\n\n    def test_get_prompt_missing(self, empty_handler):\n        \"\"\"Test getting a non-existent prompt.\"\"\"\n        with pytest.raises(ValueError, match='Prompt or variable with name \"missing\" not found'):\n            empty_handler.get_prompt(\"missing\", auto_compile=True)\n\n    def test_update_prompt(self, populated_handler):\n        \"\"\"Test updating an existing prompt.\"\"\"\n        populated_handler.update_prompt(\"GREETING\", \"Updated greeting: {name}!\")\n        assert populated_handler.prompts[\"GREETING\"] == \"Updated greeting: {name}!\"\n\n    def test_update_prompt_new(self, empty_handler):\n        \"\"\"Test updating a non-existent prompt (should create it).\"\"\"\n        empty_handler.update_prompt(\"NEW\", \"New prompt: {name}!\")\n        assert empty_handler.prompts[\"NEW\"] == \"New prompt: {name}!\"\n\n    def test_jinja_template_processing(self, empty_handler):\n        \"\"\"Test Jinja2 template processing in get_prompt.\"\"\"\n        empty_handler.create_prompt(\"jinja_test\", \"Hello [[ user_name ]]! Count: [[ count ]]\")\n\n        result = empty_handler.get_prompt(\"jinja_test\", user_name=\"Alice\", count=5, auto_compile=True)\n        assert result == \"Hello Alice! Count: 5\"\n\n    def test_jinja_template_with_mixed_syntax(self, empty_handler):\n        \"\"\"Test Jinja2 template with mixed {variable} and [[variable]] syntax.\"\"\"\n        empty_handler.create_prompt(\"mixed\", \"Hello {name}! Count: [[ count ]]\")\n\n        result = empty_handler.get_prompt(\"mixed\", context={\"name\": \"Bob\"}, count=10, auto_compile=True)\n        assert result == \"Hello Bob! Count: 10\"\n\n    def test_jinja_template_whitespace_handling(self, empty_handler):\n        \"\"\"Test Jinja2 template with whitespace in variables.\"\"\"\n        empty_handler.create_prompt(\"whitespace\", \"Hello [[ user_name ]]! Count: [[ count ]]\")\n\n        result = empty_handler.get_prompt(\"whitespace\", user_name=\"Charlie\", count=15, auto_compile=True)\n        assert result == \"Hello Charlie! Count: 15\"\n\n    def test_jinja_template_missing_variable(self, empty_handler):\n        \"\"\"Test Jinja2 template with missing variable.\"\"\"\n        empty_handler.create_prompt(\"missing_var\", \"Hello [[ user_name ]]! Count: [[ count ]]\")\n\n        # with pytest.raises(Exception):  # Jinja2 will raise an exception\n        prompt = empty_handler.get_prompt(\"missing_var\", user_name=\"David\", auto_compile=True)\n        assert \"Count: \" in prompt\n\n    def test_jinja_template_autoescape(self, empty_handler):\n        \"\"\"Test Jinja2 autoescape functionality.\"\"\"\n        empty_handler.create_prompt(\"escape_test\", \"Hello [[ user_name ]]! HTML: [[ html ]]\")\n\n        result = empty_handler.get_prompt(\n            \"escape_test\", user_name=\"Eve\", html=\"<script>alert('xss')</script>\", auto_compile=True\n        )\n        assert \"&lt;script&gt;\" in result  # Should be escaped\n\n    def test_complex_jinja_template(self, empty_handler):\n        \"\"\"Test complex Jinja2 template with multiple variables.\"\"\"\n        template = \"\"\"\n        User: [[ user_name ]]\n        Age: [[ age ]]\n        Status: [[ status ]]\n        Messages: [[ message_count ]]\n        \"\"\"\n        empty_handler.create_prompt(\"complex\", template)\n\n        result = empty_handler.get_prompt(\n            \"complex\", user_name=\"Grace\", age=30, status=\"active\", message_count=42, auto_compile=True\n        )\n        assert \"User: Grace\" in result\n        assert \"Age: 30\" in result\n        assert \"Status: active\" in result\n        assert \"Messages: 42\" in result",
      "type": "registry:file",
      "target": "packages/py-prompthandler/src/faktion/prompthandler/test/test_in_memory.py"
    }
  ],
  "categories": [
    "recipes"
  ]
}